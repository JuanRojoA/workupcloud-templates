// checkbox-input.tsx

import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";

/**
 * Represents an option in the checkbox group.
 */
interface CheckboxOption {
	label: string;
	value: string;
}

/**
 * Props for the CheckboxInput component.
 */
interface CheckboxInputProps {
	label: string;
	name: string;
	options: CheckboxOption[];
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
}

/**
 * A checkbox group component integrated with React Hook Form.
 *
 * The `CheckboxInput` component renders a group of checkboxes based on provided options.
 * It integrates seamlessly with React Hook Form and Zod for form state management and validation.
 *
 * ### Usage Example:
 *
 * ```jsx
 * import React from "react";
 * import { useForm, FormProvider } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { CheckboxInput } from "@/components/CheckboxInput";
 *
 * const FormSchema = z.object({
 *   hobbies: z.array(z.string()).min(1, { message: "Select at least one hobby." }),
 * });
 *
 * const Example = () => {
 *   const methods = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const { handleSubmit, formState: { errors } } = methods;
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *     console.log("Form Data:", data);
 *   };
 *
 *   const hobbyOptions = [
 *     { label: "Reading", value: "reading" },
 *     { label: "Traveling", value: "traveling" },
 *     { label: "Cooking", value: "cooking" },
 *     { label: "Gaming", value: "gaming" },
 *   ];
 *
 *   return (
 *     <FormProvider {...methods}>
 *       <form onSubmit={handleSubmit(onSubmit)}>
 *         <CheckboxInput
 *           label="Select Your Hobbies"
 *           name="hobbies"
 *           options={hobbyOptions}
 *           error={errors.hobbies}
 *           wrapperClassName="mb-4"
 *         />
 *         <button type="submit">Submit</button>
 *       </form>
 *     </FormProvider>
 *   );
 * };
 * ```
 *
 * @component
 * @param {CheckboxInputProps} props - Props for configuring the CheckboxInput component.
 * @param {string} props.label - The label for the checkbox group.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {CheckboxOption[]} props.options - The list of options to render as checkboxes.
 * @param {string} [props.wrapperClassName] - Additional class names for the checkbox group wrapper.
 * @param {string} [props.className] - Additional class names for each checkbox item.
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.id] - The id of the checkbox group.
 *
 * @returns {JSX.Element} The rendered CheckboxInput component.
 */
export const CheckboxInput = ({
	label,
	name,
	options,
	wrapperClassName,
	className,
	id,
	error,
}: CheckboxInputProps): JSX.Element => {
	const { register, setValue, watch } = useFormContext();
	const selectedValues: string[] = watch(name) || [];

	const handleChange = (value: string) => {
		if (selectedValues.includes(value)) {
			setValue(
				name,
				selectedValues.filter((v) => v !== value),
				{ shouldValidate: true },
			);
		} else {
			setValue(name, [...selectedValues, value], { shouldValidate: true });
		}
	};

	return (
		<div className={cn("flex flex-col", wrapperClassName)} id={id}>
			<span className="mb-2 text-sm font-medium text-zinc-700">{label}</span>
			<div className="flex flex-col space-y-2">
				{options.map((option) => (
					<div key={option.value} className="flex items-top space-x-2">
						<Checkbox
							{...register(name)}
							id={option.value}
							checked={selectedValues.includes(option.value)}
							onCheckedChange={() => handleChange(option.value)}
							className={className}
						/>
						<div className="grid gap-1.5 leading-none">
							<label
								htmlFor={option.value}
								className="text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
							>
								{option.label}
							</label>
						</div>
					</div>
				))}
			</div>
			{error && (
				<p className="mt-1 text-sm text-red-500" role="alert">
					{error.message}
				</p>
			)}
		</div>
	);
};


// floating-label-color-picker.tsx

import type React from "react";
import { useState, useId, useMemo } from "react";
import { cn } from "@/lib/utils.ts";
import { Button } from "@/components/ui/button.tsx";
import {
	Popover,
	PopoverContent,
	PopoverTrigger,
} from "@/components/ui/popover.tsx";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";
import { HexColorInput, HexColorPicker } from "react-colorful";
import { XIcon } from "lucide-react";

/**
 * Props for the FloatingLabelColorPicker component.
 */
interface FloatingLabelColorPickerProps {
	label: string;
	name: string;
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
	disabled?: boolean;
	colorPickerProps?: Omit<
		React.ComponentProps<typeof HexColorPicker>,
		"color" | "onChange"
	>;
}

/**
 * A color picker component with a floating label, integrated with React Hook Form.
 *
 * The `FloatingLabelColorPicker` component provides a color picker field with a label that animates to a floating position
 * when the picker is focused or contains a value. It integrates seamlessly with React Hook Form and Zod for form state management
 * and validation.
 *
 * ### Usage Examples:
 *
 * ```jsx
 * import { useForm, FormProvider } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { FloatingLabelColorPicker } from "@/components/FloatingLabelColorPicker";
 *
 * const FormSchema = z.object({
 *   color: z.string().nonempty({ message: "Please select a color." }),
 * });
 *
 * const Example = () => {
 *   const methods = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const { handleSubmit, formState: { errors } } = methods;
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *     console.log("Form Data:", data);
 *   };
 *
 *   return (
 *     <FormProvider {...methods}>
 *       <form onSubmit={handleSubmit(onSubmit)}>
 *         <FloatingLabelColorPicker
 *           label="Select Color"
 *           name="color"
 *           error={errors.color}
 *           wrapperClassName="mb-4"
 *         />
 *         <button type="submit">Submit</button>
 *       </form>
 *     </FormProvider>
 *   );
 * };
 * ```
 *
 * @component
 * @param {FloatingLabelColorPickerProps} props - Props for configuring the FloatingLabelColorPicker component.
 * @param {string} props.label - The label for the color picker field.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.wrapperClassName] - Additional class names for the color picker wrapper.
 * @param {string} [props.className] - Additional class names for the color picker component.
 * @param {string} [props.id] - The id of the color picker component.
 * @param {boolean} [props.disabled] - Whether the color picker is disabled.
 * @param {object} [props.colorPickerProps] - Additional props to pass to the color picker component.
 *
 * @returns {JSX.Element} The rendered FloatingLabelColorPicker component.
 */
export const FloatingLabelColorPicker = ({
	label,
	name,
	wrapperClassName,
	className,
	id,
	error,
	disabled = false,
	colorPickerProps = {},
}: FloatingLabelColorPickerProps) => {
	const uniqueId = useId();
	const inputId = id || uniqueId;

	const { register, setValue, watch } = useFormContext();

	const [open, setOpen] = useState(false);
	const [isFocused, setIsFocused] = useState(false);

	// Get the current value from React Hook Form
	const selectedValue = watch(name) || "";

	// Register the hidden input
	const { ref: _ref, ...inputProps } = register(name);

	const handleChange = (color: string) => {
		setValue(name, color, { shouldValidate: true });
	};

	const hasValue = selectedValue !== "";

	const presetColors = useMemo(() => {
		return [
			"#f44336",
			"#9c27b0",
			"#673ab7",
			"#3f51b5",
			"#2196f3",
			"#03a9f4",
			"#009688",
			"#4caf50",
			"#8bc34a",
			"#cddc39",
			"#ffeb3b",
			"#ffc107",
			"#ff5722",
		];
	}, []);

	return (
		<div className={cn("relative", wrapperClassName)}>
			<div className="relative w-full h-max bg-transparent">
				<input
					{...inputProps}
					type="hidden"
					id={inputId}
					name={name}
					value={selectedValue}
				/>
				<Popover open={open} onOpenChange={setOpen}>
					<PopoverTrigger asChild>
						<Button
							variant="outline"
							// biome-ignore lint/a11y/useSemanticElements: <explanation>
							role="combobox"
							aria-expanded={open}
							className={cn(
								"w-full justify-between font-normal peer text-left hover:bg-white",
								!hasValue && "text-muted-foreground",
								{ "border-primary": isFocused },
								{ "border-red-500": error },
								className,
							)}
							onFocus={() => setIsFocused(true)}
							onBlur={() => setIsFocused(false)}
							disabled={disabled}
						>
							{hasValue ? (
								<div className="flex items-center">
									<div
										className="w-4 h-4 mr-2 rounded"
										style={{ backgroundColor: selectedValue }}
									/>
									{selectedValue}
								</div>
							) : (
								<span className="text-muted-foreground">Pick a color</span>
							)}
						</Button>
					</PopoverTrigger>
					<PopoverContent
						className="w-auto p-2"
						align="start"
						side="bottom"
						sideOffset={5}
					>
						<div className="flex flex-col gap-2 w-full">
							<HexColorPicker
								color={selectedValue}
								onChange={handleChange}
								{...colorPickerProps}
							/>
							<div className="grid grid-cols-8 gap-2">
								{presetColors.map((color) => (
									<button
										aria-label={`Select ${color}`}
										key={color}
										type="button"
										className={cn(
											"flex items-center justify-center rounded-md border border-zinc-200 transition-all duration-200 ease-in-out hover:bg-zinc-100 focus-visible:ring-1 focus-visible:ring-zinc-950 focus-visible:outline-none",
											{
												"bg-zinc-100": selectedValue === color,
											},
										)}
										onClick={() => handleChange(color)}
									>
										<div
											className="w-full h-4 rounded"
											style={{ backgroundColor: color }}
										/>
									</button>
								))}
								<button
									type="button"
									aria-label="Clear color"
									className="flex items-center justify-center rounded-md border border-zinc-200 transition-all duration-200 ease-in-out hover:bg-zinc-100 focus-visible:ring-1 focus-visible:ring-zinc-950 focus-visible:outline-none col-span-3"
									onClick={() => handleChange("")}
								>
									<XIcon className="h-3 w-3" />
									<span className="text-xs font-normal ml-1">Clear</span>
								</button>
							</div>
							<HexColorInput
								className="bg-zinc-50 border border-zinc-200 rounded-md px-3 py-2 w-full focus:outline-none focus-visible:ring-1 focus-visible:ring-zinc-950"
								color={selectedValue}
								onChange={handleChange}
								placeholder="Type a color"
								prefixed
								alpha
							/>
						</div>
					</PopoverContent>
				</Popover>
				<label
					htmlFor={inputId}
					className={cn(
						"absolute left-3 top-[50%] transform -translate-y-1/2 transition-all duration-200 ease-in-out text-zinc-600 pointer-events-none bg-white px-1 leading-[0]",
						{
							"text-xs -top-0.5 left-2 font-semibold bg-zinc-100 rounded-md px-1":
								hasValue || isFocused,
							"text-sm": !hasValue && !isFocused,
							"text-red-500": error,
						},
					)}
				>
					{label}
				</label>
			</div>
			{error && (
				<p
					id={`${inputId}-error`}
					className="mt-1 text-sm text-red-500"
					role="alert"
				>
					{error.message}
				</p>
			)}
		</div>
	);
};

FloatingLabelColorPicker.displayName = "FloatingLabelColorPicker";


// floating-label-date-picker.tsx

import type React from "react";
import { useState, useId } from "react";
import { cn } from "@/lib/utils.ts";
import { Button } from "@/components/ui/button.tsx";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { Calendar } from "@/components/ui/calendar.tsx";
import {
	Popover,
	PopoverContent,
	PopoverTrigger,
} from "@/components/ui/popover.tsx";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";
import type { DateRange } from "react-day-picker";

/**
 * Modes supported by the FloatingLabelDatePicker.
 */
type DatePickerMode = "single" | "range" | "multiple";

/**
 * Props for the FloatingLabelDatePicker component.
 */
interface FloatingLabelDatePickerProps {
	label: string;
	name: string;
	mode?: DatePickerMode;
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
	disabled?: boolean;
	/** Additional props to pass to the Calendar component */
	calendarProps?: Omit<
		React.ComponentProps<typeof Calendar>,
		"mode" | "selected" | "onSelect"
	>;
}

/**
 * A date picker component with a floating label, integrated with React Hook Form.
 *
 * The `FloatingLabelDatePicker` component provides a date picker field with a label that animates to a floating position
 * when the picker is focused or contains a value. It supports multiple selection modes provided by React DayPicker
 * (e.g., single date, date range, multiple dates) and integrates seamlessly with React Hook Form and Zod for form state management
 * and validation.
 *
 * ### Usage Examples:
 *
 * ```jsx
 * import { useForm, FormProvider } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { FloatingLabelDatePicker } from "@/components/FloatingLabelDatePicker";
 *
 * const FormSchema = z.object({
 *   date: z.date({ required_error: "Please select a date." }),
 * });
 *
 * const Example = () => {
 *   const methods = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const { handleSubmit, formState: { errors } } = methods;
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *     console.log("Form Data:", data);
 *   };
 *
 *   return (
 *     <FormProvider {...methods}>
 *       <form onSubmit={handleSubmit(onSubmit)}>
 *         <FloatingLabelDatePicker
 *           label="Select Date"
 *           name="date"
 *           error={errors.date}
 *           wrapperClassName="mb-4"
 *         />
 *         <button type="submit">Submit</button>
 *       </form>
 *     </FormProvider>
 *   );
 * };
 * ```
 *
 * @component
 * @param {FloatingLabelDatePickerProps} props - Props for configuring the FloatingLabelDatePicker component.
 * @param {string} props.label - The label for the date picker field.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {DatePickerMode} [props.mode="single"] - The selection mode for the date picker ("single", "range", "multiple").
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.wrapperClassName] - Additional class names for the date picker wrapper.
 * @param {string} [props.className] - Additional class names for the date picker component.
 * @param {string} [props.id] - The id of the date picker component.
 * @param {boolean} [props.disabled] - Whether the date picker is disabled.
 * @param {object} [props.calendarProps] - Additional props to pass to the Calendar component.
 *
 * @returns {JSX.Element} The rendered FloatingLabelDatePicker component.
 */
export const FloatingLabelDatePicker = ({
	label,
	name,
	mode = "single",
	wrapperClassName,
	className,
	id,
	error,
	disabled = false,
	calendarProps = {},
}: FloatingLabelDatePickerProps): JSX.Element => {
	const uniqueId = useId();
	const inputId = id || uniqueId;

	const { register, setValue, watch } = useFormContext();

	const [open, setOpen] = useState(false);
	const [isFocused, setIsFocused] = useState(false);

	// Get the current value from React Hook Form
	const selectedValue = watch(name);

	// Register the hidden input
	const { ref: _ref, ...inputProps } = register(name);

	const handleSelect = (date: Date | Date[] | DateRange | undefined) => {
		setValue(name, date, { shouldValidate: true });
	};

	const formatValue = () => {
		if (!selectedValue) return "";

		if (mode === "single" && selectedValue instanceof Date) {
			return format(selectedValue, "PPP");
		}

		if (mode === "range" && selectedValue?.from) {
			const { from, to } = selectedValue as DateRange;
			if (from && to) {
				return `${format(from, "LLL dd, y")} - ${format(to, "LLL dd, y")}`;
			}
			return from ? format(from, "LLL dd, y") : "";
		}

		if (mode === "multiple" && Array.isArray(selectedValue)) {
			return selectedValue.map((date) => format(date, "PPP")).join(", ");
		}

		return "";
	};

	const hasValue = Boolean(selectedValue);

	return (
		<div className={cn("relative", wrapperClassName)}>
			<div className="relative w-full h-max bg-transparent">
				<input
					{...inputProps}
					type="hidden"
					id={inputId}
					name={name}
					value={selectedValue ? JSON.stringify(selectedValue) : ""}
				/>
				<Popover open={open} onOpenChange={setOpen}>
					<PopoverTrigger asChild>
						<Button
							variant="outline"
							// biome-ignore lint/a11y/useSemanticElements: <explanation>
							role="combobox"
							aria-expanded={open}
							className={cn(
								"w-full justify-between font-normal peer text-left hover:bg-white",
								!hasValue && "text-muted-foreground",
								{ "border-primary": isFocused },
								{ "border-red-500": error },
								className,
							)}
							onFocus={() => setIsFocused(true)}
							onBlur={() => setIsFocused(false)}
							disabled={disabled}
						>
							{hasValue ? (
								formatValue()
							) : (
								<span className="text-muted-foreground">Pick a date</span>
							)}
							<CalendarIcon className="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</Button>
					</PopoverTrigger>
					<PopoverContent
						className="w-auto p-0"
						align="start"
						side="bottom"
						sideOffset={5}
					>
						<Calendar
							mode={mode}
							selected={selectedValue}
							onSelect={handleSelect}
							initialFocus
							{...calendarProps}
						/>
					</PopoverContent>
				</Popover>
				<label
					htmlFor={inputId}
					className={cn(
						"absolute left-3 top-[50%] transform -translate-y-1/2 transition-all duration-200 ease-in-out text-zinc-600 pointer-events-none bg-white px-1 leading-[0]",
						{
							"text-xs -top-0.5 left-2 font-semibold bg-zinc-100 rounded-md px-1":
								hasValue || isFocused || open,
							"text-sm": !hasValue && !isFocused && !open,
							"text-red-500": error,
						},
					)}
				>
					{label}
				</label>
			</div>
			{error && (
				<p
					id={`${inputId}-error`}
					className="mt-1 text-sm text-red-500"
					role="alert"
				>
					{error.message}
				</p>
			)}
		</div>
	);
};

FloatingLabelDatePicker.displayName = "FloatingLabelDatePicker";


// floating-label-input.tsx

import React, { useState, useId } from "react";
import { cn } from "@/lib/utils.ts";
import { Input } from "@/components/ui/input.tsx";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";

type InputType =
	| "text"
	| "password"
	| "email"
	| "number"
	| "tel"
	| "url"
	| "search";

/**
 * Props for the FloatingLabelInput component.
 */
interface FloatingLabelInputProps
	extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "type"> {
	type?: InputType;
	label: string;
	name: string;
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
}

/**
 * An input component with a floating label, integrated with React Hook Form.
 *
 * The `FloatingLabelInput` component provides an input field with a label that animates to a floating position
 * when the input is focused or contains a value. It integrates seamlessly with React Hook Form and Zod for form state management
 * and validation, and is designed to work well even when inputs are distributed across different parts of the UI.
 *
 * ### Features:
 * - **Floating Label**: The label smoothly transitions between its initial position and a floating position.
 * - **Form Integration**: Uses `register` from React Hook Form to integrate with form management and validation.
 * - **Accessible**: Properly associates the label with the input for screen readers and assistive technologies.
 * - **Error Handling**: Displays validation errors and associates them with the input for accessibility.
 * - **Flexible Styling**: Accepts additional class names for both the wrapper and the input for easy customization.
 *
 * ### Usage Examples:
 *
 * ```jsx
 * import { useForm } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { FloatingLabelInput } from "@/components/FloatingLabelInput";
 *
 * const FormSchema = z.object({
 *   email: z.string().email({ message: "Invalid email address." }),
 * });
 *
 * const Example = () => {
 *   const { register, handleSubmit, formState: { errors } } = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *   };
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <FloatingLabelInput
 *         label="Email"
 *         type="email"
 *         name="email"
 *         error={errors.email}
 *         wrapperClassName="mb-4"
 *       />
 *       <button type="submit">Submit</button>
 *     </form>
 *   );
 * };
 * ```
 *
 * @component
 * @param {FloatingLabelInputProps} props - Props for configuring the FloatingLabelInput component.
 * @param {InputType} [props.type="text"] - The type of the input element.
 * @param {string} props.label - The label for the input field.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.wrapperClassName] - Additional class names for the input wrapper.
 * @param {string} [props.className] - Additional class names for the input element.
 * @param {string} [props.id] - The id of the input element.
 *
 * @returns {JSX.Element} The rendered FloatingLabelInput component.
 */
export const FloatingLabelInput = React.memo(
	({
		type = "text",
		label,
		name,
		wrapperClassName,
		className,
		id,
		error,
		...rest
	}: FloatingLabelInputProps) => {
		const uniqueId = useId();
		const inputId = id || uniqueId;

		const { register, watch } = useFormContext();

		const [isFocused, setIsFocused] = useState(false);

		const value = watch(name) || "";

		const hasValue = value !== "";

		return (
			<div className={cn("relative", wrapperClassName)}>
				<div className="relative w-full h-max bg-transparent">
					<Input
						{...register(name)}
						id={inputId}
						type={type}
						name={name}
						className={cn(
							"peer placeholder-transparent placeholder-shown:placeholder-transparent",
							{ "border-primary": isFocused },
							{ "border-red-500": error },
							className,
						)}
						aria-invalid={error ? "true" : "false"}
						aria-describedby={error ? `${inputId}-error` : undefined}
						onFocus={(e) => {
							setIsFocused(true);
							rest.onFocus?.(e);
						}}
						onBlur={(e) => {
							setIsFocused(false);
							rest.onBlur?.(e);
						}}
						{...rest}
					/>
					<label
						htmlFor={inputId}
						className={cn(
							"absolute left-3 top-[47%] transform -translate-y-1/2 transition-all duration-200 ease-in-out text-zinc-600 pointer-events-none bg-white px-1 leading-[0]",
							{
								"text-xs -top-0.5 left-2 font-semibold bg-zinc-100 rounded-md px-1":
									hasValue || isFocused,
								"text-sm": !hasValue && !isFocused,
								"text-red-500": error,
							},
						)}
					>
						{label}
					</label>
				</div>
				{error && (
					<p
						id={`${inputId}-error`}
						className="mt-1 text-sm text-red-500"
						role="alert"
					>
						{error.message}
					</p>
				)}
			</div>
		);
	},
);

FloatingLabelInput.displayName = "FloatingLabelInput";


// floating-label-select.tsx

import { useState, useId } from "react";
import { cn } from "@/lib/utils.ts";
import { Button } from "@/components/ui/button.tsx";
import {
	Command,
	CommandEmpty,
	CommandGroup,
	CommandInput,
	CommandItem,
	CommandList,
} from "@/components/ui/command.tsx";
import {
	Popover,
	PopoverContent,
	PopoverTrigger,
} from "@/components/ui/popover.tsx";
import { Check, ChevronsUpDown } from "lucide-react";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";

interface FloatingLabelSelectProps {
	label: string;
	name: string;
	options: Array<{ label: string; value: string }>;
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
}

/**
 * A select component with a floating label, integrated with React Hook Form.
 *
 * The `FloatingLabelSelect` component provides a select field with a label that animates to a floating position
 * when the select is focused or contains a value. It uses a hidden input to integrate with React Hook Form and Zod,
 * allowing for seamless form state management and validation.
 *
 * ### Usage Examples:
 *
 * ```jsx
 * import { useForm } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { FloatingLabelSelect } from "@/components/FloatingLabelSelect";
 *
 * const languages = [
 *   { label: "English", value: "en" },
 *   { label: "French", value: "fr" },
 *   // ...more options
 * ];
 *
 * const FormSchema = z.object({
 *   language: z.string().nonempty({ message: "Please select a language." }),
 * });
 *
 * const Example = () => {
 *   const { register, handleSubmit, formState: { errors } } = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *   };
 *
 *   return (
 *     <form onSubmit={handleSubmit(onSubmit)}>
 *       <FloatingLabelSelect
 *         label="Language"
 *         name="language"
 *         options={languages}
 *         error={errors.language}
 *         wrapperClassName="mb-4"
 *       />
 *       <button type="submit">Submit</button>
 *     </form>
 *   );
 * };
 * ```
 *
 * @component
 * @param {FloatingLabelSelectProps} props - Props for configuring the FloatingLabelSelect component.
 * @param {string} props.label - The label for the select field.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {Array<{ label: string; value: string }>} props.options - The options for the select field.
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.wrapperClassName] - Additional class names for the select wrapper.
 * @param {string} [props.className] - Additional class names for the select component.
 * @param {string} [props.id] - The id of the select component.
 *
 * @returns {JSX.Element} The rendered FloatingLabelSelect component.
 */
export const FloatingLabelSelect = ({
	label,
	name,
	options,
	wrapperClassName,
	className,
	id,
	error,
	...rest
}: FloatingLabelSelectProps): JSX.Element => {
	const uniqueId = useId();
	const inputId = id || uniqueId;

	const { register, setValue, watch } = useFormContext();

	const [open, setOpen] = useState(false);
	const [isFocused, setIsFocused] = useState(false);

	const selectedValue = watch(name) || "";

	const handleChange = (value: string) => {
		setValue(name, value, { shouldValidate: true });
	};

	const hasValue = selectedValue !== "";

	return (
		<div className={cn("relative", wrapperClassName)}>
			<div className="relative w-full h-max bg-transparent">
				<input
					{...register(name)}
					type="hidden"
					id={inputId}
					name={name}
					value={selectedValue}
				/>
				<Popover open={open} onOpenChange={setOpen}>
					<PopoverTrigger asChild>
						<Button
							variant="outline"
							// biome-ignore lint/a11y/useSemanticElements: <explanation>
							role="combobox"
							aria-expanded={open}
							className={cn(
								"w-full justify-between font-normal peer text-left hover:bg-white",
								!hasValue && "text-muted-foreground",
								{ "border-primary": isFocused },
								{ "border-red-500": error },
								className,
							)}
							onFocus={() => setIsFocused(true)}
							onBlur={() => setIsFocused(false)}
							{...rest}
						>
							{selectedValue ? (
								options.find((option) => option.value === selectedValue)?.label
							) : (
								<p />
							)}
							<ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
						</Button>
					</PopoverTrigger>
					<PopoverContent className="w-[--radix-popover-trigger-width] max-h-[--radix-popover-content-available-height] p-2">
						<Command className="w-full">
							<CommandInput placeholder={`Search ${label}...`} />
							<CommandList>
								<CommandEmpty>No {label} found.</CommandEmpty>
								<CommandGroup>
									{options.map((option) => (
										<CommandItem
											keywords={[option.label]}
											key={option.value}
											value={option.value}
											onSelect={(currentValue) => {
												handleChange(
													currentValue === selectedValue ? "" : currentValue,
												);
												setOpen(false);
											}}
										>
											<Check
												className={cn(
													"mr-2 h-4 w-4",
													selectedValue === option.value
														? "opacity-100"
														: "opacity-0",
												)}
											/>
											{option.label}
										</CommandItem>
									))}
								</CommandGroup>
							</CommandList>
						</Command>
					</PopoverContent>
				</Popover>
				<label
					htmlFor={inputId}
					className={cn(
						"absolute left-3 top-[50%] transform -translate-y-1/2 transition-all duration-200 ease-in-out text-zinc-600 pointer-events-none bg-white px-1 leading-[0]",
						{
							"text-xs -top-0.5 left-2 font-semibold bg-zinc-100 rounded-md px-1":
								hasValue || isFocused || open,
							"text-sm": !hasValue && !isFocused && !open,
							"text-red-500": error,
						},
					)}
				>
					{label}
				</label>
			</div>
			{error && (
				<p
					id={`${inputId}-error`}
					className="mt-1 text-sm text-red-500"
					role="alert"
				>
					{error.message}
				</p>
			)}
		</div>
	);
};

FloatingLabelSelect.displayName = "FloatingLabelSelect";


// floating-label-textarea.tsx

import type React from "react";
import { useState, useId } from "react";
import { cn } from "@/lib/utils.ts";
import { Textarea } from "@/components/ui/textarea.tsx";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";

/**
 * Props for the FloatingLabelTextarea component.
 */
interface FloatingLabelTextareaProps
	extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, "name"> {
	label: string;
	name: string;
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
	rows?: number;
}

/**
 * A textarea component with a floating label, integrated with React Hook Form.
 *
 * The `FloatingLabelTextarea` component provides a textarea field with a label that animates to a floating position
 * when the textarea is focused or contains a value. It integrates seamlessly with React Hook Form and Zod for form state management
 * and validation.
 *
 * ### Usage Examples:
 *
 * ```jsx
 * import React from "react";
 * import { useForm, FormProvider } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { FloatingLabelTextarea } from "@/components/FloatingLabelTextarea";
 *
 * const FormSchema = z.object({
 *   message: z.string().min(10, { message: "Message must be at least 10 characters long." }),
 * });
 *
 * const Example = () => {
 *   const methods = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const { handleSubmit, formState: { errors } } = methods;
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *     console.log("Form Data:", data);
 *   };
 *
 *   return (
 *     <FormProvider {...methods}>
 *       <form onSubmit={handleSubmit(onSubmit)}>
 *         <FloatingLabelTextarea
 *           label="Your Message"
 *           name="message"
 *           error={errors.message}
 *           wrapperClassName="mb-4"
 *           rows={5}
 *         />
 *         <button type="submit">Submit</button>
 *       </form>
 *     </FormProvider>
 *   );
 * };
 * ```
 *
 * @component
 * @param {FloatingLabelTextareaProps} props - Props for configuring the FloatingLabelTextarea component.
 * @param {string} props.label - The label for the textarea field.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.wrapperClassName] - Additional class names for the textarea wrapper.
 * @param {string} [props.className] - Additional class names for the textarea element.
 * @param {string} [props.id] - The id of the textarea element.
 * @param {number} [props.rows=4] - Number of visible text lines for the control.
 *
 * @returns {JSX.Element} The rendered FloatingLabelTextarea component.
 */
export const FloatingLabelTextarea = ({
	label,
	name,
	wrapperClassName,
	className,
	id,
	error,
	rows = 4,
	...rest
}: FloatingLabelTextareaProps): JSX.Element => {
	const uniqueId = useId();
	const inputId = id || uniqueId;

	const { register, watch } = useFormContext();

	const [isFocused, setIsFocused] = useState(false);

	const value = watch(name) || "";

	const hasValue = value !== "";

	return (
		<div className={cn("relative", wrapperClassName)}>
			<div className="relative w-full h-max bg-transparent">
				<Textarea
					{...register(name)}
					id={inputId}
					name={name}
					rows={rows}
					className={cn(
						"peer placeholder-transparent resize-none",
						{ "border-primary": isFocused },
						{ "border-red-500": error },
						className,
					)}
					aria-invalid={error ? "true" : "false"}
					aria-describedby={error ? `${inputId}-error` : undefined}
					onFocus={(e) => {
						setIsFocused(true);
						rest.onFocus?.(e);
					}}
					onBlur={(e) => {
						setIsFocused(false);
						rest.onBlur?.(e);
					}}
					{...rest}
				/>
				<label
					htmlFor={inputId}
					className={cn(
						"absolute left-3 top-[20px] transform -translate-y-1/2 transition-all duration-200 ease-in-out text-zinc-600 pointer-events-none bg-white px-1",
						{
							"text-xs -top-0.5 left-2 font-semibold bg-zinc-100 rounded-md px-1":
								hasValue || isFocused,
							"text-sm": !hasValue && !isFocused,
							"text-red-500": error,
						},
					)}
				>
					{label}
				</label>
			</div>
			{error && (
				<p
					id={`${inputId}-error`}
					className="mt-1 text-sm text-red-500"
					role="alert"
				>
					{error.message}
				</p>
			)}
		</div>
	);
};

FloatingLabelTextarea.displayName = "FloatingLabelTextarea";


// radio-button-input.tsx

import { useId } from "react";
import { cn } from "@/lib/utils";
import { useFormContext } from "react-hook-form";
import type { FieldError } from "react-hook-form";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

/**
 * Represents an option in the radio button group.
 */
interface RadioOption {
	label: string;
	value: string;
}

/**
 * Props for the RadioButtonInput component.
 */
interface RadioButtonInputProps {
	label: string;
	name: string;
	options: RadioOption[];
	wrapperClassName?: string;
	className?: string;
	error?: FieldError;
	id?: string;
}

/**
 * A radio button group component integrated with React Hook Form.
 *
 * The `RadioButtonInput` component renders a group of radio buttons based on provided options.
 * It integrates seamlessly with React Hook Form and Zod for form state management and validation.
 *
 * ### Usage Example:
 *
 * ```jsx
 * import React from "react";
 * import { useForm, FormProvider } from "react-hook-form";
 * import { z } from "zod";
 * import { zodResolver } from "@hookform/resolvers/zod";
 * import { RadioButtonInput } from "@/components/RadioButtonInput";
 *
 * const FormSchema = z.object({
 *   gender: z.string().nonempty({ message: "Please select a gender." }),
 * });
 *
 * const Example = () => {
 *   const methods = useForm({
 *     resolver: zodResolver(FormSchema),
 *   });
 *
 *   const { handleSubmit, formState: { errors } } = methods;
 *
 *   const onSubmit = (data) => {
 *     // Handle form submission
 *     console.log("Form Data:", data);
 *   };
 *
 *   const genderOptions = [
 *     { label: "Male", value: "male" },
 *     { label: "Female", value: "female" },
 *     { label: "Other", value: "other" },
 *   ];
 *
 *   return (
 *     <FormProvider {...methods}>
 *       <form onSubmit={handleSubmit(onSubmit)}>
 *         <RadioButtonInput
 *           label="Select Your Gender"
 *           name="gender"
 *           options={genderOptions}
 *           error={errors.gender}
 *           wrapperClassName="mb-4"
 *         />
 *         <button type="submit">Submit</button>
 *       </form>
 *     </FormProvider>
 *   );
 * };
 * ```
 *
 * @component
 * @param {RadioButtonInputProps} props - Props for configuring the RadioButtonInput component.
 * @param {string} props.label - The label for the radio button group.
 * @param {string} props.name - The name of the form field (required for form integration).
 * @param {RadioOption[]} props.options - The list of options to render as radio buttons.
 * @param {string} [props.wrapperClassName] - Additional class names for the radio group wrapper.
 * @param {string} [props.className] - Additional class names for each radio button item.
 * @param {FieldError} [props.error] - The error object from React Hook Form.
 * @param {string} [props.id] - The id of the radio group.
 *
 * @returns {JSX.Element} The rendered RadioButtonInput component.
 */
export const RadioButtonInput = ({
	label,
	name,
	options,
	wrapperClassName,
	className,
	id,
	error,
}: RadioButtonInputProps) => {
	const { register, setValue, watch } = useFormContext();
	const selectedValue = watch(name);

	return (
		<div className={cn("flex flex-col", wrapperClassName)}>
			<span className="mb-2 text-sm font-medium text-zinc-700">{label}</span>
			<RadioGroup
				id={id || useId()}
				{...register(name)}
				defaultValue={selectedValue}
				onValueChange={(value) =>
					setValue(name, value, { shouldValidate: true })
				}
			>
				{options.map((option) => (
					<div key={option.value} className="flex items-center space-x-2">
						<RadioGroupItem
							value={option.value}
							id={option.value}
							className={className}
						/>
						<Label
							htmlFor={option.value}
							className="text-sm font-normal leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
						>
							{option.label}
						</Label>
					</div>
				))}
			</RadioGroup>
			{error && (
				<p className="mt-1 text-sm text-red-500" role="alert">
					{error.message}
				</p>
			)}
		</div>
	);
};


